# 弹药柜控制系统状态机设计方案

## 1. 项目背景

弹药柜控制系统涉及四个核心业务流：
- **正常业务流 (A/B交互)**: 遵循 `申请 -> 授权 -> 操作 -> 复位` 的严格时序
- **强制干预流 (钥匙)**: 物理钥匙开门直接触发报警
- **环境触发流 (震动)**: 传感器触发立即报警
- **后台监控流 (C类)**: 网络、心跳、长期开门未关等自动监控

本文档探讨如何使用状态机模式将这四个业务流有机结合，确保系统的安全性、一致性和可维护性。

## 2. 业务流特性分析

### 2.1 正常业务流特性
- **时序严格性**: 必须按预定顺序执行，不可跳过
- **人机交互**: 需要操作员A申请、操作员B授权的双重确认
- **状态可逆**: 支持授权取消，可回退到初始状态
- **时间敏感**: 授权有时效性，长期未操作需要复位

### 2.2 强制干预流特性
- **最高优先级**: 钥匙操作具有最高权限，可打断任何流程
- **立即响应**: 触发后立即进入报警状态，无需等待
- **人工确认**: 需要人工核实并取消报警
- **审计要求**: 所有钥匙操作必须记录和审计

### 2.3 环境触发流特性
- **实时性要求**: 震动检测需要毫秒级响应
- **持续监控**: 24小时不间断环境监测
- **误报处理**: 需要机制处理传感器误报
- **历史追溯**: 保留震动事件历史用于分析

### 2.4 后台监控流特性
- **定期检查**: 按设定周期检查系统健康状态
- **多种指标**: 网络连通性、设备心跳、门状态等
- **渐进处理**: 支持警告级别分级处理
- **自动恢复**: 部分异常支持自动恢复机制

## 3. 状态机模式对比分析

### 3.1 单一状态机模式

#### 架构描述
所有业务流整合在一个统一的状态机中，通过状态组合管理所有可能的系统状态。

#### 状态空间设计
```
主状态: IDLE, NORMAL_FLOW, ALARM_STATE, MAINTENANCE, ERROR
子状态:
- NORMAL_FLOW: REQUESTED, AUTHORIZED, DOOR_OPEN, OPERATION_COMPLETE
- ALARM_STATE: KEY_ALARM, VIBRATION_ALARM, MONITOR_ALARM
- ERROR: NETWORK_ERROR, HEARTBEAT_LOST, LONG_OPEN
```

#### 优势
✅ **状态一致性保证**: 全局唯一状态源，避免状态冲突
✅ **决策逻辑简化**: 任何时刻只需判断当前状态
✅ **优先级体系清晰**: 可以建立严格的事件优先级
✅ **调试和测试友好**: 完整的状态转换路径

#### 劣势
❌ **状态组合爆炸**: 状态数量呈指数级增长
❌ **维护复杂度高**: 修改一个业务流影响整个状态机
❌ **单点性能瓶颈**: 所有事件通过同一状态机处理
❌ **扩展性受限**: 新增业务流需要重构整个状态机

### 3.2 多状态机并行模式

#### 架构描述
每个业务流独立的状态机，通过协调机制处理状态机间的交互和冲突。

#### 架构布局
```
正常流SM    钥匙干预SM    震动报警SM    监控SM
    │           │           │          │
    └─── 协调器/仲裁器 ────┘
```

#### 优势
✅ **模块化程度高**: 每个业务流职责单一、独立
✅ **故障隔离**: 一个状态机故障不影响其他
✅ **并行开发**: 不同团队可并行开发不同状态机
✅ **独立部署**: 支持状态机的独立升级和部署

#### 劣势
❌ **协调机制复杂**: 需要设计复杂的状态机间通信
❌ **一致性挑战**: 多个状态机可能出现状态冲突
❌ **优先级处理困难**: 跨状态机事件优先级难以统一
❌ **测试复杂度高**: 需要测试各种状态机交互组合

## 4. 推荐方案：主从式混合状态机

### 4.1 架构设计原则

基于弹药柜系统的安全关键特性和业务需求，采用主从式混合架构：

```
┌─────────────────────────────────────┐
│          主协调状态机               │
│    (IDLE, NORMAL, ALARM, ERROR)     │
└─────────────┬───────────────────────┘
              │ 主从协调
    ┌─────────┼─────────┐
    │         │         │
┌───▼───┐ ┌──▼──┐ ┌────▼────┐
│正常流SM│ │报警SM│ │监控SM   │
└───────┘ └─────┘ └─────────┘
```

### 4.2 主协调状态机设计

#### 状态定义
```typescript
enum MainState {
  IDLE = 'idle',              // 系统空闲，等待任何输入
  NORMAL = 'normal',          // 正常业务流进行中
  ALARM = 'alarm',            // 报警状态（任何类型）
  ERROR = 'error'             // 系统错误状态
}
```

#### 事件优先级体系
1. **P0 - 紧急**: 钥匙开门、震动报警
2. **P1 - 高**: 监控异常报警
3. **P2 - 中**: 正常业务流程操作
4. **P3 - 低**: 系统维护和诊断

#### 状态转换规则
```typescript
const transitionRules = {
  [MainState.IDLE]: {
    'apply_request': MainState.NORMAL,      // 申请供弹
    'key_detected': MainState.ALARM,        // 钥匙开门
    'vibration_detected': MainState.ALARM,  // 震动报警
    'monitor_anomaly': MainState.ALARM,     // 监控异常
  },
  [MainState.NORMAL]: {
    'operation_complete': MainState.IDLE,    // 正常流程完成
    'key_detected': MainState.ALARM,        // 钥匙可打断
    'vibration_detected': MainState.ALARM,  // 震动可打断
    'monitor_anomaly': MainState.ALARM,     // 监控异常可打断
  },
  [MainState.ALARM]: {
    'alarm_cancelled': MainState.IDLE,      // 报警取消
  },
  [MainState.ERROR]: {
    'error_resolved': MainState.IDLE,        // 错误解决
  }
};
```

### 4.3 子状态机设计

#### 4.3.1 正常流状态机
```typescript
enum NormalFlowState {
  IDLE = 'idle',
  REQUESTED = 'requested',      // 申请已提交
  AUTHORIZED = 'authorized',    // 已授权，可开锁
  DOOR_OPEN = 'door_open',      // 门已开，可取弹
  OPERATION = 'operation',      // 操作中
  COMPLETE = 'complete',        // 操作完成，等待复位
  CANCELLED = 'cancelled'       // 已取消
}
```

**状态转换条件：**
- `REQUESTED` → `AUTHORIZED`: 收到授权信号
- `AUTHORIZED` → `DOOR_OPEN`: 门磁检测到开门
- `DOOR_OPEN` → `OPERATION`: 检测到取弹操作
- `OPERATION` → `COMPLETE`: 门关闭并上锁
- `CANCELLED` → `IDLE`: 复位申请按钮

#### 4.3.2 报警统一状态机
```typescript
enum AlarmType {
  KEY_INTRUSION = 'key_intrusion',    // 钥匙入侵
  VIBRATION = 'vibration',            // 震动报警
  MONITOR_ANOMALY = 'monitor_anomaly' // 监控异常
}

enum AlarmState {
  DETECTED = 'detected',      // 报警检测到
  ACTIVE = 'active',          // 报警激活中
  ACKNOWLEDGED = 'acknowledged', // 已确认
  CANCELLED = 'cancelled'     // 已取消
}
```

**统一处理流程：**
1. 检测到报警源 → `DETECTED`
2. 激活报警输出 → `ACTIVE`
3. 人工确认 → `ACKNOWLEDGED`
4. 取消报警 → `CANCELLED`

#### 4.3.3 监控状态机
```typescript
enum MonitorState {
  HEALTHY = 'healthy',              // 系统正常
  WARNING = 'warning',              // 警告级别
  CRITICAL = 'critical',            // 严重级别
  RECOVERY = 'recovery'             // 恢复中
}
```

**监控指标：**
- 网络连通性检查
- 设备心跳检测
- 门状态长时间未关闭
- 传感器健康状态

### 4.4 状态同步机制

#### 4.4.1 主从通信协议
```typescript
interface StateMachineMessage {
  from: 'main' | 'normal' | 'alarm' | 'monitor';
  to: string;
  type: 'state_change' | 'event' | 'query';
  payload: {
    state?: string;
    event?: string;
    data?: any;
    timestamp: number;
  };
}
```

#### 4.4.2 状态一致性保证
- **主状态权威**: 主协调器持有全局权威状态
- **心跳同步**: 子状态机定期向主状态机报告状态
- **冲突仲裁**: 主状态机负责解决状态冲突
- **事务性操作**: 关键状态变更采用事务模式

### 4.5 事件处理流程

#### 4.5.1 事件接收和分发
```typescript
class EventDispatcher {
  async handleEvent(event: SystemEvent) {
    // 1. 优先级判断
    const priority = this.getEventPriority(event);

    // 2. 主协调器预检查
    const canHandle = await this.mainSM.canHandle(event);
    if (!canHandle) {
      return this.rejectEvent(event, 'State conflict');
    }

    // 3. 分发到对应子状态机
    const targetSM = this.getTargetStateMachine(event);
    const result = await targetSM.handleEvent(event);

    // 4. 主协调器状态更新
    await this.mainSM.syncWithSubMachine(targetSM, result);

    return result;
  }
}
```

#### 4.5.2 冲突解决策略
- **抢占式**: 高优先级事件可打断低优先级操作
- **排队式**: 同优先级事件按到达顺序处理
- **回滚式**: 被打断的操作可选择回滚或暂停

## 5. 实现技术要点

### 5.1 关键数据结构

#### 系统全局状态
```typescript
interface SystemState {
  mainState: MainState;
  subStates: {
    normal?: NormalFlowState;
    alarm?: AlarmState;
    monitor?: MonitorState;
  };
  context: {
    currentOperation?: string;
    alarmSources: AlarmType[];
    lastEvent: SystemEvent;
    operationHistory: OperationRecord[];
  };
  timestamp: number;
}
```

#### 状态转换记录
```typescript
interface StateTransition {
  fromState: string;
  toState: string;
  event: string;
  machine: string;
  timestamp: number;
  user?: string;
  metadata?: any;
}
```

### 5.2 性能优化考虑

#### 状态机实例池
- 预创建状态机实例，避免运行时创建开销
- 使用对象池管理状态机生命周期
- 状态转换使用查找表，避免条件判断

#### 事件队列管理
- 优先级队列确保高优先级事件优先处理
- 批量处理降低系统调用开销
- 异步处理避免阻塞主线程

### 5.3 安全性保障

#### 状态转换验证
```typescript
class StateTransitionValidator {
  validateTransition(
    from: State,
    to: State,
    event: Event,
    context: SecurityContext
  ): ValidationResult {
    // 1. 权限检查
    if (!this.hasPermission(context.user, event)) {
      return ValidationResult.denied('Insufficient permissions');
    }

    // 2. 状态合法性检查
    if (!this.isValidTransition(from, to, event)) {
      return ValidationResult.denied('Invalid state transition');
    }

    // 3. 时序约束检查
    if (!this.checkTimingConstraints(from, to, context)) {
      return ValidationResult.denied('Timing constraint violation');
    }

    return ValidationResult.granted();
  }
}
```

#### 审计日志
- 所有状态转换记录不可篡改的审计日志
- 关键操作支持数字签名
- 提供状态回溯和分析功能

## 6. 部署和运维考虑

### 6.1 状态持久化
- 定期保存系统状态快照
- 断电重启后可恢复到正确状态
- 支持状态历史查询和回滚

### 6.2 监控和告警
- 状态机性能指标监控
- 异常状态转换告警
- 状态机健康状态检查

### 6.3 升级和维护
- 支持热更新状态转换规则
- 渐进式部署新业务流
- 向后兼容的版本管理

## 7. 总结

主从式混合状态机方案通过以下设计解决了弹药柜控制系统的复杂需求：

### 7.1 架构优势
- **统一协调**: 主状态机确保全局状态一致性
- **专业分工**: 子状态机专注各自业务领域
- **优先级清晰**: 严格的事件优先级体系保证关键操作及时响应
- **扩展友好**: 新增业务流只需增加对应的子状态机

### 7.2 实施价值
- **安全性提升**: 状态转换的严格验证和审计
- **可维护性改善**: 模块化设计便于定位和修复问题
- **性能优化**: 并行处理和事件队列机制提高响应速度
- **演进支持**: 为未来功能扩展预留了架构空间

### 7.3 风险控制
- **故障隔离**: 子状态机故障不影响整体系统
- **状态恢复**: 完善的持久化和恢复机制
- **测试覆盖**: 分层测试策略确保系统可靠性

这种设计既满足了弹药柜系统对安全性和可靠性的严格要求，又为系统的长期演进奠定了坚实基础。