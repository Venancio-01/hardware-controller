# Dockerfile.build
# 用于构建 ARM v7 部署包的多阶段 Dockerfile
#
# 功能：
# 1. 在 ARM v7 环境中安装依赖（编译 serialport 原生模块）
# 2. 编译 TypeScript
# 3. 将后端代码编译为 V8 字节码 (.jsc)
# 4. 混淆前端 JavaScript 代码
#
# 使用方法:
#   docker buildx build --platform linux/arm/v7 -f Dockerfile.build -t node-switch:arm7-build --load .

# ============================================
# 阶段1: 构建阶段
# ============================================
FROM --platform=linux/arm/v7 node:20-slim AS builder

WORKDIR /app

# 安装构建工具
RUN apt-get update && apt-get install -y \
    python3 \
    make \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# 安装 pnpm
RUN npm install -g pnpm

# 安装 bytenode 和 javascript-obfuscator
RUN npm install -g bytenode javascript-obfuscator

# 复制 pnpm 配置文件
COPY package.json pnpm-lock.yaml pnpm-workspace.yaml .npmrc ./

# 复制各个包的 package.json
COPY packages/shared/package.json packages/shared/
COPY packages/core/package.json packages/core/
COPY packages/backend/package.json packages/backend/
COPY packages/frontend/package.json packages/frontend/

# 安装依赖（包括 serialport 原生模块编译）
RUN pnpm install --frozen-lockfile

# 复制源代码
COPY packages ./packages
COPY tsconfig.json ./
COPY config.json5 ./
COPY obfuscator.config.cjs ./

# ============================================
# 阶段2: 编译 TypeScript
# ============================================

# 构建 shared
RUN cd packages/shared && pnpm build

# 构建 core
RUN cd packages/core && pnpm build

# 构建 backend
RUN cd packages/backend && pnpm build

# 构建 frontend
RUN cd packages/frontend && pnpm build

# ============================================
# 阶段3: 编译为 V8 字节码
# ============================================

# 强制打破缓存以重新编译
RUN echo "Force Rebuild Bytecode 001"

# 编译 shared 为 V8 字节码 (跳过：Shared 仅进行混淆/压缩，保留为 minified JS)
# RUN echo "Skipping shared bytecode compilation"

# 编译 core 为 V8 字节码
RUN for file in $(find packages/core/dist -name "*.cjs" ! -name "*.d.cjs"); do \
      echo "Compiling $file..."; \
      bytenode -c "$file" || exit 1; \
    done \
    && find packages/core/dist -name "*.cjs" ! -name "*.d.cjs" -delete

# 编译 backend 为 V8 字节码
RUN for file in $(find packages/backend/dist -name "*.cjs" ! -name "*.d.cjs"); do \
      echo "Compiling $file..."; \
      bytenode -c "$file" || exit 1; \
    done \
    && find packages/backend/dist -name "*.cjs" ! -name "*.d.cjs" -delete

# ============================================
# 阶段4: 混淆前端代码
# ============================================

# 混淆前端 JavaScript（使用配置文件）
RUN for file in $(find packages/frontend/dist/assets -name "*.js"); do \
      javascript-obfuscator "$file" --output "$file" --config obfuscator.config.cjs; \
    done

# ============================================
# 阶段5: 整理输出结构
# ============================================

# 移动构建产物到顶层目录
RUN mv packages/backend/dist backend \
    && mv packages/core/dist core \
    && mv packages/shared/dist shared \
    && mv packages/frontend/dist public

# 清理 devDependencies，仅保留生产依赖
RUN CI=true pnpm prune --prod

# 清理不需要的文件
RUN rm -rf packages tsconfig.json

# 最终检查：确认没有明文 .js 文件（除了 public 目录）
RUN echo "=== 字节码编译验证 ===" \
    && echo "Backend .jsc 文件数量:" && find backend -name "*.jsc" | wc -l \
    && echo "Core .jsc 文件数量:" && find core -name "*.jsc" | wc -l \
    && echo "Shared .jsc 文件数量:" && find shared -name "*.jsc" | wc -l \
    && echo "Backend 剩余 .js 文件:" && find backend -name "*.js" | wc -l \
    && echo "Core 剩余 .js 文件:" && find core -name "*.js" | wc -l \
    && echo "Shared 剩余 .js 文件:" && find shared -name "*.js" | wc -l

# 输出最终目录结构
RUN echo "=== 最终目录结构 ===" && ls -la

# 设置一个空的 CMD，因为这个镜像仅用于提取文件
CMD ["/bin/true"]
