# Web 界面配置工具 PRD

## 产品概述

**文档版本：** 2.0
**产品：** Node-switch 项目的 Web 界面配置工具
**更新日期：** 2025-12-26

本文档概述了 node-switch 项目 Web 界面配置工具的要求。该界面将提供一种用户友好的方式来修改项目配置和硬件系统设置，包括 IP 地址等网络配置。该界面将取代直接文件编辑的需要，并通过基于浏览器的仪表板提供集中、易访问的系统级和应用程序级设置管理。

本版本新增了 **进程分离架构**，将 Core（硬件控制核心）与 Web（Backend + Frontend）分离为两个独立进程，以提高系统可靠性和可维护性。

---

## 目标

### 业务目标
- 减少手动配置更改所花费的时间
- 为非技术用户提供配置管理的易访问性
- 集中配置管理以减少错误和不一致
- 为未来功能扩展提供基础
- 实现远程配置管理能力
- **提高系统可靠性**：Web 界面保持可用，即使 Core 发生故障
- **实现热重启**：配置更改后可单独重启 Core，无需中断 Web 服务
- **增强可维护性**：独立进程便于日志分析、性能监控和故障排查

### 用户目标
- 无需直接文件访问即可轻松修改应用程序设置
- 通过直观界面配置硬件系统参数
- 可视化监控当前配置状态
- 在应用前验证配置更改
- 从任何具有浏览器的设备访问配置管理
- 通过 Web 界面 **监控 Core 进程状态**（运行中/已停止/错误）
- 通过 Web 界面 **重启 Core 进程**（手动或自动）
- 配置修改后 **需手动触发重启** 以应用更改
- 获得 Core 运行状态的 **实时反馈**

### 非目标
- 替换现有硬件控制功能
- 实现超出配置的复杂硬件诊断
- 提供实时硬件监控（超出配置状态）
- 替换高级用户的命令行工具
- 包括硬件固件更新功能
- 不改变 Core 的业务逻辑和硬件控制功能
- 不实现分布式部署（仍为单机部署）
- 不更改 Frontend 与 Backend 的通信方式

---

## 系统架构

### 进程分离架构

#### 背景

当前架构中，Backend 服务启动时直接调用 `startApp()` 在同一进程内启动 Core 应用。这种紧耦合设计存在以下问题：

1. **无法独立监控**：Core 崩溃会导致 Web 服务一起崩溃
2. **无法独立重启**：配置更改后需要重启整个应用，影响 Web 服务可用性
3. **故障隔离缺失**：硬件异常可能影响用户界面的响应

#### 目标架构

```
┌─────────────────────────────────────────┐
│         Web 进程 (Supervisor)            │
│  ┌──────────────┐  ┌─────────────────┐  │
│  │   Frontend   │◄─│    Backend      │  │
│  │   (Vite)     │  │   (Express)     │  │
│  └──────────────┘  └────────┬────────┘  │
└─────────────────────────────┼───────────┘
                              │ IPC / Socket
                              ▼
                     ┌─────────────────┐
                     │   Core 进程     │
                     │  (子进程/独立)   │
                     └─────────────────┘
```

---

## 用户画像

### 主要用户类型
- **系统管理员：** 负责部署和维护的技术用户
- **运营经理：** 需要偶尔配置访问的业务用户
- **技术支持：** 需要配置访问的客户服务人员
- **开发人员：** 需要测试配置更改的团队成员

### 基本用户画像详情
- **技术水平：** 技术和非技术用户的混合
- **设备使用：** 各种设备，包括台式机、笔记本电脑和平板电脑
- **频率：** 根据角色而定的偶尔到每日使用
- **目标：** 快速、可靠的配置更改，学习曲线最小

### 基于角色的访问
- **管理员：** 对所有配置选项具有完全访问权限
- **操作员：** 仅限于应用程序级设置
- **支持：** 只读访问，能够导出配置
- **访客：** 仅查看当前配置状态

---

## 功能需求

### 配置管理功能

#### 高优先级
| ID | 需求 | 描述 |
|----|------|------|
| FR-001 | 显示配置 | 以可读格式显示当前系统和应用程序配置 |
| FR-002 | 修改应用设置 | 通过 Web 界面允许修改应用程序级设置 |
| FR-003 | 修改网络设置 | 通过 Web 界面允许修改系统级网络设置（IP 地址、网络参数） |
| FR-004 | 验证配置 | 保存前验证配置更改 |
| FR-005 | 保存配置 | 将配置更改保存到 config.json 文件 |
| FR-006 | 安全认证 | 实现配置访问的安全身份验证 |
| FR-007 | 视觉反馈 | 在保存操作期间提供视觉反馈 |

#### 中优先级
| ID | 需求 | 描述 |
|----|------|------|
| FR-008 | 导入导出 | 允许配置文件的导入/导出 |
| FR-011 | 错误显示 | 明确显示配置验证错误 |
| FR-012 | 测试网络 | 允许在应用前测试网络配置 |

### 进程管理功能

#### 高优先级
| ID | 需求 | 描述 |
|----|------|------|
| FR-101 | 进程分离 | Backend 使用 `child_process` API 启动 Core 作为独立子进程 |
| FR-102 | 状态监控 | Backend 监控 Core 进程状态（启动、运行、停止、崩溃） |
| FR-103 | 进程重启 | Backend 能够优雅地停止并重启 Core 进程 |
| FR-104 | 进程通信 | 建立 Backend 与 Core 之间的 IPC 通信通道 |
| FR-105 | 状态 API | 提供 REST API 供 Frontend 查询 Core 状态 |
| FR-106 | 重启 API | 提供 REST API 供 Frontend 触发 Core 重启 |

#### 中优先级
| ID | 需求 | 描述 |
|----|------|------|
| FR-107 | 自动恢复 | Core 崩溃后自动重启（可配置重试次数） |
| FR-108 | 手动重启应用配置 | 配置修改后，用户需通过界面手动触发 Core 重启以应用更改 |
| FR-109 | 日志转发 | Core 日志通过 IPC 转发到 Backend 统一管理 |
| FR-110 | 状态推送 | 通过 WebSocket 实时推送 Core 状态变化到 Frontend |

#### 低优先级
| ID | 需求 | 描述 |
|----|------|------|
| FR-111 | 启动超时 | 配置 Core 启动超时时间，超时视为启动失败 |
| FR-112 | 健康检查 | 定期心跳检测 Core 运行状况 |

---

## 技术设计

### 进程管理模块

**位置：** `packages/backend/src/core-manager/`

```typescript
// core-manager.ts
interface CoreProcessManager {
  // 启动 Core 进程
  start(): Promise<void>;

  // 停止 Core 进程（优雅关闭）
  stop(): Promise<void>;

  // 重启 Core 进程
  restart(): Promise<void>;

  // 获取当前状态
  getStatus(): CoreStatus;

  // 状态变化事件
  on(event: 'status-change', handler: (status: CoreStatus) => void): void;
}

type CoreStatus =
  | 'starting'   // 正在启动
  | 'running'    // 运行中
  | 'stopping'   // 正在停止
  | 'stopped'    // 已停止
  | 'crashed';   // 异常退出
```

### IPC 通信协议

使用 Node.js 内置的 `child_process.fork()` 建立 IPC 通道，消息格式：

```typescript
interface IPCMessage {
  type: 'status' | 'log' | 'error' | 'command' | 'heartbeat';
  payload: unknown;
  timestamp: number;
}
```

### API 端点设计

| 方法 | 端点 | 描述 |
|------|------|------|
| GET | `/api/system/core/status` | 获取 Core 进程状态 |
| POST | `/api/system/core/restart` | 触发 Core 重启 |
| POST | `/api/system/core/stop` | 停止 Core 进程 |
| POST | `/api/system/core/start` | 启动 Core 进程 |

---

## 用户体验

### 入口点
- 显示当前配置摘要的主仪表板
- 导航到不同配置部分的菜单
- 频繁修改设置的快速访问面板

### 核心体验
- 用于配置修改的直观表单界面
- 用户输入值时的实时验证
- 已保存/未保存状态的清晰视觉指示

### 高级功能
- 配置导入/导出功能
- 系统级网络配置工具

### UI/UX 亮点
- 专注于配置任务的简洁、最小界面
- 清晰的错误消息和验证反馈
- 保存操作期间的进度指示器
- 相关配置选项的直观分组
- 与现有项目美学一致的样式

---

## 叙述

作为系统管理员，我希望通过 Web 界面轻松配置和管理我的 node-switch 应用程序，以便我可以在不需要直接文件访问的情况下修改设置。当我访问配置界面时，我应该看到一个干净的仪表板，逻辑地显示我的当前设置。我应该能够通过直观的表单修改应用程序参数，如超时、网络配置和硬件特定设置。在保存之前，系统应该验证我的更改并提醒我任何潜在问题。保存后，我应该收到确认信息，表明更改已成功应用，并且系统将在重新启动时或适当时立即使用新配置。

此外，我可以在 Web 界面上实时监控 Core 进程的运行状态。如果 Core 崩溃，Web 界面仍然可用，我可以查看崩溃信息并触发重启。配置更改保存后，系统会询问我是否立即重启 Core 以应用新配置，整个过程无需中断 Web 服务。

---

## 成功指标

### 用户中心指标
| 指标 | 目标 |
|------|------|
| 配置更改完成率 | >95% |
| 完成常见配置任务的时间 | <5 分钟 |
| 配置界面的用户满意度评分 | >4.0/5.0 |
| 配置更改错误率 | <2% |

### 业务指标
| 指标 | 目标 |
|------|------|
| 配置相关支持工单的减少 | 减少 30% |
| 配置更改部署的加快 | 加快 50% |
| 配置相关任务耗时的减少 | 减少 40% |

### 技术指标
| 指标 | 目标 |
|------|------|
| 界面加载时间 | <3 秒 |
| 配置验证准确性 | 100% |
| 配置更改期间的系统可用性 | 99.9% |
| 安全合规性遵守程度 | 100% |

### 进程管理指标
| 指标 | 目标 |
|------|------|
| Core 崩溃后 Web 可用性 | 100%（Web 服务不受影响） |
| 自动恢复成功率 | ≥95% |
| 重启响应时间 | <5 秒 |

---

## 技术考虑

### 集成点
- 与现有 config.json 存储系统的直接集成
- 与当前 TypeScript 5.9.3 和 Node.js >=22.0.0 栈的兼容性
- 与 Zod v4.2.1 验证架构系统的集成
- 与 XState v5.12.1 状态管理的兼容性
- 用于硬件交互的 UDP/TCP 通信协议

### 数据存储/隐私
- 配置数据以 config.json 格式安全存储
- 适当的访问控制以防止未经授权的配置更改

### 可扩展性/性能
- 支持多用户同时配置访问
- 配置更改的有效验证
- 配置操作期间对系统性能的最小影响
- 配置数据检索的缓存机制
- 配置表单的优化渲染

### 代码影响分析

**需要修改的文件：**

1. `packages/backend/src/index.ts`
   - 移除直接调用 `startApp()` 的代码
   - 使用 CoreProcessManager 启动和管理 Core

2. `packages/core/src/app.ts`
   - 添加 IPC 消息处理
   - 发送状态更新到父进程

3. `packages/backend/src/routes/system.routes.ts`
   - 添加 Core 进程管理相关的 API 端点

**新增模块：**

1. `packages/backend/src/core-manager/`
   - `core-manager.ts` - 进程管理器
   - `ipc-handler.ts` - IPC 通信处理
   - `types.ts` - 类型定义

### 潜在挑战

| 挑战 | 解决方案 |
|------|----------|
| 确保与现有系统架构的兼容性 | 渐进式重构，保持接口兼容 |
| 在提供 Web 访问的同时保持安全性 | 实现身份验证和授权机制 |
| 处理可能影响连接性的网络配置更改 | 提供配置测试和回滚机制 |
| 管理对配置文件的并发访问 | 实现文件锁定机制 |
| 验证复杂的配置关系 | 使用 Zod 进行深度验证 |
| 进程间状态同步 | 使用 IPC 事件驱动架构，确保状态实时同步 |
| 优雅关闭处理 | 发送 SIGTERM 信号，等待超时后强制终止 |
| 开发环境调试 | 支持单进程模式用于开发调试 |
| 日志统一管理 | Core 日志通过 IPC 转发到 Backend 统一输出 |

---

## 里程碑和排序

### 项目估算
- **总持续时间：** 10-14 周
- **开发小时数：** 400-560 小时

### 团队规模
- 2-3 名前端开发人员
- 1-2 名后端开发人员
- 1 名 QA 工程师
- 1 名 UX 设计师（兼职）

### 建议阶段

#### 第 1 阶段：进程分离基础（1-2 周）
- [ ] 实现 CoreProcessManager 基础功能
- [ ] 修改 Backend 启动逻辑
- [ ] 修改 Core 支持作为子进程运行
- [ ] 实现基本 IPC 通信

#### 第 2 阶段：核心界面开发和身份验证（2-3 周）
- [ ] 开发基础 Web 界面框架
- [ ] 实现用户身份验证系统
- [ ] 创建主仪表板页面

#### 第 3 阶段：应用程序级配置功能（2-3 周）
- [ ] 实现配置读取和显示
- [ ] 实现配置修改表单
- [ ] 实现配置验证和保存

#### 第 4 阶段：进程管理 API 与监控（1 周）
- [ ] 实现状态查询 API
- [ ] 实现重启控制 API
- [ ] 添加状态变化日志
- [ ] 实现崩溃自动恢复

#### 第 5 阶段：系统级配置和验证（1-2 周）
- [ ] 实现网络配置管理
- [ ] 实现配置测试功能
- [ ] 实现手动重启流程

#### 第 6 阶段：Frontend 进程管理集成（1 周）
- [ ] 添加 Core 状态显示组件
- [ ] 添加重启操作按钮
- [ ] 实现状态实时更新

#### 第 7 阶段：测试和安全实施（1-2 周）
- [ ] 进行全面功能测试
- [ ] 安全审计和加固
- [ ] 性能优化

#### 第 8 阶段：最终测试、部署和文档（1 周）
- [ ] 最终集成测试
- [ ] 编写用户文档
- [ ] 部署准备

---

## 用户故事

### 配置管理用户故事

#### US-001：查看当前配置
**标题：** 系统管理员查看当前配置
**描述：** 作为系统管理员，我希望以可读格式查看当前系统和应用程序配置，以便在进行更改前了解当前状态。
**验收标准：**
- 配置以有组织、可读的格式显示
- 系统级和应用程序级设置都可见
- 配置值有明确标记
- 界面在 3 秒内加载
- 响应式设计适用于不同屏幕尺寸

#### US-002：修改应用程序设置
**标题：** 用户修改应用程序级设置
**描述：** 作为系统管理员，我希望通过 Web 界面修改应用程序级设置，以便我可以调整参数而无需直接编辑文件。
**验收标准：**
- 所有应用程序设置都提供表单字段
- 可以更改设置值
- 提供实时输入验证
- 表单字段与 config.json 中定义的数据类型匹配
- 提供取消选项以放弃更改

#### US-003：修改网络设置
**标题：** 用户修改系统级网络设置
**描述：** 作为系统管理员，我希望修改 IP 地址等系统级网络设置，以便我可以通过 Web 界面配置网络参数。
**验收标准：**
- 提供网络配置字段（IP、子网、网关、DNS）
- 提供 IP 地址格式验证
- 保存前验证网络设置
- 对潜在破坏性更改显示警告
- 变更可以立即应用或在重启时应用

#### US-004：验证配置更改
**标题：** 系统在保存前验证配置
**描述：** 作为系统管理员，我希望在保存前验证配置更改，以便我可以避免可能破坏系统的无效配置。
**验收标准：**
- 在修改设置时进行实时验证
- 为无效值显示清晰的错误消息
- 验证规则与 Zod 架构定义匹配
- 验证配置依赖关系
- 无效配置无法保存

#### US-005：保存配置更改
**标题：** 用户将配置更改保存到文件
**描述：** 作为系统管理员，我希望将配置更改保存到 config.json 文件，以便系统使用新设置。
**验收标准：**
- 配置更改保存到 config.json 文件
- 保存后显示成功确认
- 系统可以在保存后重新加载新配置
- 保存期间维护文件权限
- 保持配置文件完整性

#### US-006：安全身份验证
**标题：** 用户在访问配置界面前进行身份验证
**描述：** 作为系统管理员，我希望在访问配置界面前进行身份验证，以便未授权用户无法修改系统设置。
**验收标准：**
- 访问配置前需要身份验证
- 执行强密码要求
- 会话超时防止未授权访问
- 记录登录尝试以供安全监控
- 禁用身份验证绕过机制

#### US-007：保存期间的视觉反馈
**标题：** 系统在保存操作期间提供反馈
**描述：** 作为系统管理员，我希望在保存操作期间获得视觉反馈，以便我知道系统正在处理我的更改。
**验收标准：**
- 保存操作期间显示进度指示器
- 保存完成后显示成功确认
- 保存失败时显示错误消息
- 保存操作期间禁用保存按钮
- 明确传达操作状态

#### US-008：导入配置文件
**标题：** 用户从文件导入配置
**描述：** 作为系统管理员，我希望从文件导入配置，以便我可以应用以前导出或准备的配置。
**验收标准：**
- 配置导入提供文件上传界面
- 应用前验证导入的配置
- 验证文件格式兼容性
- 应用前显示导入设置的预览
- 完成前可以取消导入操作

#### US-009：导出配置文件
**标题：** 用户将当前配置导出到文件
**描述：** 作为系统管理员，我希望将当前配置导出到文件，以便我可以备份设置或将它们应用到其他系统。
**验收标准：**
- 提供当前配置的导出功能
- 按正确格式生成配置文件
- 导出文件包含所有当前设置
- 导出文件可用于在其他系统上导入
- 导出操作成功完成

#### US-010：配置更改历史
**标题：** 用户访问配置更改历史
**描述：** 作为系统管理员，我希望查看配置更改历史，以便我可以跟踪修改并可能回滚到以前的状态。
**验收标准：**
- 配置更改历史已存储并可访问
- 可以详细查看历史配置
- 如需要可以恢复以前的配置
- 记录更改时间戳和用户
- 历史条目按时间顺序适当组织

#### US-012：显示配置错误
**标题：** 系统显示配置验证错误
**描述：** 作为系统管理员，我希望配置验证错误清晰显示，以便我可以了解并修复配置更改中的问题。
**验收标准：**
- 验证错误显示在相关字段附近
- 错误消息具体且可操作
- 错误高亮视觉上明显
- 错误持续存在直到解决
- 可以同时显示多个错误

#### US-013：测试网络配置
**标题：** 用户在应用前测试网络配置
**描述：** 作为系统管理员，我希望在应用前测试网络配置更改，以便我可以避免失去系统连接。
**验收标准：**
- 提供网络配置测试界面
- 应用设置前可以执行连接性测试
- 测试结果清晰显示
- 测试操作不永久更改设置
- 测试失败时提供安全回退机制

#### US-014：基于角色的访问控制
**标题：** 系统执行基于角色的访问控制
**描述：** 作为运营经理，我希望基于角色的访问控制，以便我只能修改适合我角色的配置设置。
**验收标准：**
- 执行基于角色的访问权限
- 不同用户角色看到适当的界面选项
- 禁用未授权的配置选项
- 访问日志记录用户特定操作
- 可配置角色分配

#### US-015：移动响应式界面
**标题：** 界面在移动设备上工作
**描述：** 作为系统管理员，我希望配置界面在移动设备上工作，以便我可以随时随地进行紧急配置更改。
**验收标准：**
- 界面在移动屏幕尺寸上响应
- 提供触摸友好的控件
- 移动设备上导航正常工作
- 移动设备上性能可接受
- 所有关键功能在移动设备上可访问

#### US-016：批量配置更改
**标题：** 用户执行批量配置更改
**描述：** 作为系统管理员，我希望通过 CSV 导入执行批量配置更改，以便我可以高效地一次更新多个设置。
**验收标准：**
- 提供批量更改的 CSV 导入界面
- 处理前验证 CSV 格式
- 应用前显示批量更改的预览
- 应用前可以取消批量更改
- 导入过程优雅处理错误

#### US-017：暗色/亮色主题选择
**标题：** 用户选择界面主题
**描述：** 作为系统管理员，我希望在暗色和亮色主题之间选择，以便我可以在不同照明条件下舒适地工作。
**验收标准：**
- 界面中提供主题选择选项
- 正确实现暗色和亮色主题
- 为未来会话保存主题偏好
- 两种主题中所有界面元素都正常工作
- 主题选择不影响功能

#### US-018：实时配置验证
**标题：** 系统提供实时配置验证
**描述：** 作为系统管理员，我希望在输入时进行实时配置验证，以便我可以立即看到我的配置更改是否有效。
**验收标准：**
- 在输入值时进行验证
- 立即指示有效/无效状态
- 验证反馈不会干扰但可见
- 实时验证不影响性能
- 验证规则与服务器端验证一致

#### US-019：配置冲突检测
**标题：** 系统检测配置冲突
**描述：** 作为系统管理员，我希望系统检测配置冲突，以便我可以在它们导致系统问题之前解决它们。
**验收标准：**
- 检测并报告配置冲突
- 高亮显示冲突设置以引起用户注意
- 提供冲突解决方案建议
- 在冲突发生前警告系统
- 适当验证设置之间的依赖关系

#### US-020：安全配置传输
**标题：** 系统确保安全配置传输
**描述：** 作为注重安全的用户，我希望配置数据通过加密连接安全传输，以便保护敏感配置信息。
**验收标准：**
- 所有配置数据通过 HTTPS 传输
- 为所有配置操作执行加密
- 不以纯文本记录配置值
- 配置操作期间维护会话安全性
- 为安全连接实施证书验证

---

### 进程管理用户故事

#### US-101：查看 Core 进程状态
**标题：** 用户查看 Core 运行状态
**描述：** 作为系统管理员，我希望在 Web 界面上查看 Core 进程的运行状态，以便了解硬件控制系统是否正常工作。
**验收标准：**
- 显示 Core 当前状态（运行中/已停止/启动中/错误）
- 显示 Core 启动时间和运行时长
- 状态变化时自动更新（无需手动刷新）
- 错误状态时显示错误信息

#### US-102：手动重启 Core
**标题：** 用户手动重启 Core 进程
**描述：** 作为系统管理员，我希望能够通过 Web 界面手动重启 Core 进程，以便在需要时应用配置更改或恢复系统。
**验收标准：**
- 提供"重启"按钮
- 重启前显示确认对话框
- 重启过程中显示进度状态
- 重启完成后显示成功/失败提示
- 需要身份验证才能执行重启操作

#### US-103：配置更改后自动重启
**标题：** 配置保存后自动重启 Core
**描述：** 作为系统管理员，我希望保存配置后系统自动重启 Core 进程，以便新配置立即生效。
**验收标准：**
- 保存配置后提示"是否立即重启 Core 应用配置"
- 用户确认后自动执行重启
- 可选择"稍后手动重启"
- 重启过程中显示状态

#### US-104：Core 崩溃自动恢复
**标题：** Core 崩溃后自动重启
**描述：** 作为系统管理员，我希望 Core 进程崩溃后系统能够自动重启，以减少人工干预。
**验收标准：**
- Core 异常退出后自动尝试重启
- 可配置最大重试次数（默认 3 次）
- 连续失败后停止重试并发送告警
- 记录崩溃和重启日志
- Web 界面显示崩溃历史
