---
project_name: node-switch
user_name: 青山
date: '2025-12-25'
sections_completed: ['technology_stack', 'language_specific', 'framework_specific', 'testing', 'code_quality', 'workflow', 'critical_dont_miss']
existing_patterns_found: 25
---

# AI 代理的项目上下文

_本文档包含 AI 代理在此项目中实现代码时必须遵循的关键规则和模式。重点关注代理可能忽略的细节。_

---

## 技术栈和版本

- **运行时**: Node.js >=22.0.0（如 package.json engines 中指定）
- **语言**: TypeScript 5.9.3，启用严格模式
- **状态管理**: XState v5.12.1 用于复杂状态机
- **验证**: Zod v4.2.1 用于环境变量和数据验证
- **日志**: Pino v10.1.0，开发时使用 pino-pretty
- **构建工具**: tsup 用于打包
- **开发工具**: tsx 用于开发执行
- **测试**: vitest 作为测试框架
- **环境管理**: dotenv 用于配置加载

## 关键实现规则

### 语言特定规则

#### TypeScript 配置
- 使用严格模式，启用所有严格类型检查标志（strict, alwaysStrict, strictNullChecks, strictFunctionTypes 等）
- 目标 ES2022，使用 ESNext 模块系统
- 在导入中使用显式 `.js` 扩展名以兼容 Node.js
- 启用 experimentalDecorators 和 emitDecoratorMetadata 以支持潜在的装饰器使用

#### 导入/导出约定
- 在导入中使用显式 `.js` 扩展名以兼容 Node.js
- 对仅类型导入使用 `import type` 以优化包大小
- 按组组织导入：首先外部库，然后内部模块
- 为内部导入使用绝对路径（相对于 src/）

#### 错误处理模式
- 使用 Zod 进行配置验证，采用快速失败原则（验证失败时 process.exit(1)）
- 为异步操作实现 try-catch 块和适当的错误日志记录
- 为不同场景使用适当的日志级别（error, warn, info）
- 通过日志模块集中错误处理模式

### 框架特定规则

#### XState 状态机模式
- 使用 XState 5.x setup/createActor 模式定义和实例化状态机
- 在 `src/state-machines/` 目录中定义状态机，并使用描述性名称
- 使用类型安全的状态机定义，具有显式的上下文、事件和输入类型
- 使用 invoke 块实现子状态机，并通过 sendTo 操作进行通信
- 使用 actor 模型进行复杂状态管理，并建立父子关系
- 在关闭期间实现状态机 actor 的优雅清理
- 在管理状态机中的多个事件类型时使用事件优先级

### 测试规则

#### 测试结构和组织
- 使用 vitest 作为测试框架，使用 "vitest run" 执行
- 为测试文件使用 .test.ts 或 .spec.ts 扩展名
- 按与被测试源文件相同的目录结构组织测试
- 使用描述性测试名称，清楚表明测试内容

#### 测试类别
- 单元测试：测试单个函数、类和实用方法（隔离）
- 集成测试：测试模块之间的交互（例如，状态机与硬件管理器）
- 系统/端到端测试：测试完整工作流程和系统行为

#### Mock 使用
- 为外部依赖使用 vitest 的内置模拟功能
- 为单元测试模拟硬件通信以确保快速执行
- 创建真实的 mock 实现以测试状态机转换
- 当测试依赖于日志记录器和配置模块的组件时模拟它们

### 代码质量和样式规则

#### 文件和文件夹结构
- 在 src/ 下按基于功能的目录组织代码（logger, relay, voice-broadcast, hardware, state-machines 等）
- 将类型定义与实现放在一起或放在集中的 types/ 目录中
- 使用 index.ts 文件控制模块导出并创建干净的公共 API
- 在专用文件中分离验证逻辑（例如，validation.ts）

#### 命名约定
- 为变量、函数和文件名使用 camelCase
- 为类型、接口和类名使用 PascalCase
- 为常量和配置值使用 UPPER_SNAKE_CASE
- 使用清楚表明目的和功能的描述性名称
- 状态机文件应使用 `-machine.ts` 后缀以保持一致性

#### 文档和注释
- 为复杂函数、类和业务逻辑使用 JSDoc 风格的注释
- 为公共 API 包含参数和返回值描述
- 为业务逻辑和领域特定注释使用中文（按代码库标准）
- 为技术变量名和一般实现注释使用英文
- 为复杂算法和业务规则添加有意义的注释

### 开发工作流规则

#### 环境和配置
- 使用 .env 和 .env.local 文件进行环境变量管理
- 所有环境变量在启动期间必须通过 Zod 验证
- 通过 NODE_ENV 支持多种环境（开发、生产、测试）
- 配置验证遵循快速失败原则（配置无效时应用退出）

#### 构建和执行
- 使用 tsup 构建 ESM 输出格式
- 使用 tsx 进行开发执行，并使用监视模式
- 构建产物生成在 dist/ 目录中
- 在生产构建中使用 dotenv/config 进行运行时环境加载

#### 部署和运行时
- 为 SIGINT 和 SIGTERM 信号实现优雅关闭处理程序
- 在应用启动期间初始化所有硬件通信模块
- 在启动任何服务之前验证配置有效性
- 记录启动配置摘要以供调试目的

### 关键不要遗漏的规则

#### 要避免的反模式
- 不要绕过 Zod 验证访问环境变量 - 始终使用集中配置模块
- 不要直接访问硬件接口 - 始终使用 HardwareCommunicationManager 进行硬件通信
- 不要忽略配置验证失败 - 始终遵循快速失败原则（应用应退出）
- 不要在关闭期间跳过清理程序 - 确保所有状态机 actor 和硬件连接正确关闭
- 不要在状态机转换中执行阻塞操作 - 保持它们异步

#### 边界情况和错误处理
- 为硬件通信实现适当的超时和重试逻辑（使用可配置参数）
- 处理并发操作期间的状态机事件冲突（使用事件优先级）
- 验证 UDP/TCP 通信响应以防止处理格式错误的数据
- 为网络通信故障包含错误恢复机制

#### 安全考虑
- 不要以纯文本环境变量存储敏感凭据
- 在处理前验证从硬件通信接收到的所有数据
- 为包含敏感信息的配置文件使用适当的访问控制
- 实现硬件通信的速率限制以防止泛洪

#### 性能模式遵循
- 避免在高频事件路径中执行阻塞操作
- 在状态机中对耗时操作使用异步处理
- 优化高频路径中的日志频率以防止性能下降
- 在长时间运行的进程中考虑维护状态的内存使用