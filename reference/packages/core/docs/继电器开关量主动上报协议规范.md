# 继电器开关量主动上报协议规范

## 1. 协议概述

本规范适用于科星互联 2-8 路继电器/IO 板卡。当设备配置为“主动上传”模式时，输入端口（开关量）状态发生变化将触发数据帧推送。

* **通信方式**：Hex 字节流
* **触发机制**：异步上报（需预先配置）
* **适用产品**：2路、4路、8路型号
* **字节序**：N/A（单字节位掩码操作）

## 2. 前置配置

默认为 **不带锁模式**：仅上升沿（接通）上报 。


## 3. 数据帧结构

固定帧长 **9 字节**。

| 偏移 (Offset) | 字段名 | 长度 | 固定值/范围 | 描述 |
| --- | --- | --- | --- | --- |
| 0 | Header | 2 Bytes | `EE FF` | 帧头标识

 |
| 2 | Function | 1 Byte | `C0` | <br>**功能码**，标识 2-8 路开关量上报

 |
| 3 | Address | 1 Byte | `01` | 设备地址（默认 01）

 |
| 4 | **SL** | 1 Byte | BitMap | <br>**继电器当前状态** (State Relay)

 |
| 5 | **KL** | 1 Byte | BitMap | <br>**输入端口当前电平状态** (Keep Level)

 |
| 6 | **OH** | 1 Byte | BitMap | <br>**上升沿触发掩码** (On Hit)

 |
| 7 | **OL** | 1 Byte | BitMap | <br>**下降沿触发掩码** (Off Lost)

 |
| 8 | Checksum | 1 Byte | 0x00-0xFF | 校验位 (通常忽略/不关心)

 |

## 4. 字段位解析 (Bitwise Parsing)

所有状态字段 (`SL`, `KL`, `OH`, `OL`) 均为 **1 字节 (8 bits)**，位映射规则一致：

* **Bit 0 (LSB)**: 对应 第 1 路
* **Bit 1**: 对应 第 2 路
* ...
* **Bit 7 (MSB)**: 对应 第 8 路

### 4.1 SL (继电器状态)

* `0`: 断开
* `1`: 导通/吸合
* *用途*：用于同步 UI 上的继电器显示，确保输入变化时继电器状态也是最新的。

### 4.2 KL (输入保持状态)

* `0`: 无信号/断开
* `1`: 有信号/闭合
* *用途*：表示**当前时刻**所有端口的物理电平状态。

### 4.3 OH (上升沿/导通事件)

* `1`: 检测到该路**刚刚**从“断”变为“通”。
* `0`: 无变化。
* *用途*：用于触发“按下”事件逻辑。

### 4.4 OL (下降沿/断开事件)

* `1`: 检测到该路**刚刚**从“通”变为“断”。
* `0`: 无变化。
* *用途*：用于触发“松开”事件逻辑。

## 5. TypeScript 类型定义 (Reference)

```typescript
/**
 * 解析后的开关量事件对象
 */
interface SwitchInputEvent {
  deviceId: number;       // 地址，通常为 1
  relayState: boolean[];  // SL: 继电器状态 (index 0 = road 1)
  inputState: boolean[];  // KL: 当前输入电平 (index 0 = road 1)
  triggers: {
    risingEdge: number[];  // OH: 触发上升沿的路数索引列表 (e.g. [0, 4] for road 1 and 5)
    fallingEdge: number[]; // OL: 触发下降沿的路数索引列表
  };
  rawHex: string;         // 原始报文
}

/**
 * 辅助解析掩码函数
 */
function parseBitmap(byteVal: number): boolean[] {
  const states: boolean[] = [];
  for (let i = 0; i < 8; i++) {
    // 检查第 i 位是否为 1
    states.push(((byteVal >> i) & 0x01) === 1);
  }
  return states;
}

```

## 6. 解析算法流程

1. **校验帧头**：检查 Byte[0-1] 是否为 `EE FF`。
2. **校验功能码**：检查 Byte[2] 是否为 `C0`。若为其他值（如 `CE`），则属于 16 路产品协议，需走其他逻辑。
3. **提取数据**：
* 读取 Byte[4] -> `SL_Byte`
* 读取 Byte[5] -> `KL_Byte`
* 读取 Byte[6] -> `OH_Byte`
* 读取 Byte[7] -> `OL_Byte`


4. **业务逻辑分发**：
* 遍历 `OH_Byte` 的每一位。若 Bit `i` 为 1，发射 `Input_On` 事件（参数：路数 `i+1`）。
* 遍历 `OL_Byte` 的每一位。若 Bit `i` 为 1，发射 `Input_Off` 事件（参数：路数 `i+1`）。
* 更新全局状态缓存：将 `KL_Byte` 和 `SL_Byte` 更新到设备影子状态中。


## 7. 真实报文示例分析

**报文**：`EE FF C0 01 00 11 01 00 D3`

* **Header**: `EE FF` (OK)
* **Func**: `C0` (2-8路主动上报)
* **Addr**: `01`
* **SL (`00`)**: `0000 0000` -> 所有继电器均为 **OFF**。
* **KL (`11`)**: `0001 0001` -> 当前 **第1路** 和 **第5路** 输入为 **ON**。
* **OH (`01`)**: `0000 0001` -> **第1路** 刚刚触发了 **上升沿** (Pressed)。
* **OL (`00`)**: `0000 0000` -> 无断开事件。

**场景推断**：
用户按下了第 1 路开关，且第 5 路开关之前一直处于保持接通状态。



## 控制协议文档

## 1. 协议概述

* **通信接口**: RS485 / TTL / TCP (视具体硬件而定)
* **波特率**: 默认 9600, N, 8, 1
*
**核心机制**: 采用“控制位”+“使能位（掩码）”逻辑，支持单指令同时操作多路，且互不干扰 。


* **指令选择**:
* **方案 A (推荐)**: 使用 `A1` 短指令（基于实际测试与 `A2` 校验算法）。帧长短，效率高，适合 2-8 路设备。

---

## 2. 核心控制逻辑 (Mask 机制)

1. **使能位 (Enable / Mask)**: 决定**哪些路**允许被修改。
* `1`: 允许修改。
* `0`: 保持原状态（忽略控制位）。


2. **控制位 (Set / State)**: 决定目标状态。
* `1`: 导通 (ON)。
* `0`: 断开 (OFF)。



> **例**: 仅打开第 2 路，保持第 1 路不变。
> * 使能位 = `0000 0010` (0x02) -> 只授权第 2 路。
> * 控制位 = `0000 0010` (0x02) -> 第 2 路设为 ON。
>
>

---

## 3. 方案 A：A1 短帧控制指令 (高效/推荐)

*适用场景：2-8 路设备日常开关控制。*

### 3.1 帧结构 (10 Bytes)

| 字节 | 值/名称 | 描述 |
| --- | --- | --- |
| 0-1 | `CC DD` | 帧头 |
| 2 | `A1` | **功能码** (短帧控制) |
| 3 | `01` | 设备地址 (默认) |
| 4 | `SH` | 控制位高 8 位 (2-8路通常为 00) |
| 5 | `SL` | **控制位低 8 位** (对应 1-8 路) |
| 6 | `EH` | 使能位高 8 位 (2-8路通常为 00) |
| 7 | `EL` | **使能位低 8 位** (对应 1-8 路) |
| 8 | `CH` | 校验和高位 (算法见下文) |
| 9 | `CL` | 校验和低位 |

### 3.2 校验算法

与文档中 `A2` 指令校验算法一致 ：

1. `CH` = 功能码(`A1`) + 地址(`01`) + 控制位(`SH+SL`) + 使能位(`EH+EL`)
2. `CL` = `CH` + `CH` (取低 8 位)
3. 最终取 `CH` 和 `CL` 的低 8 位。

### 3.3 示例 (Hex)

* **打开第 2 路** (Mask=0x02, Set=0x02)
* 发送: `CC DD A1 01 00 02 00 02 A6 4C`


* **关闭第 2 路** (Mask=0x02, Set=0x00)
* 发送: `CC DD A1 01 00 00 00 02 A4 48`


* **同时打开第 1、2 路** (Mask=0x03, Set=0x03)
* 计算 CH: `A1 + 01 + 03 + 03 = A8`
* 计算 CL: `A8 + A8 = 150 -> 50`
* 发送: `CC DD A1 01 00 03 00 03 A8 50`


### 3.4 响应帧 (成功确认)

控制指令执行成功后，设备将返回确认帧。

* **返回**: `4F 4B 21`
* **ASCII 解析**: `OK!`
* **含义**: 继电器状态设置成功


### 4.1 帧结构 (19 Bytes)

| 字节 | 值 | 含义 | 2-8路配置说明 |
| --- | --- | --- | --- |
| 0-1 | `CC DD` | 帧头 | - |
| 2 | `A3` | 功能码 | - |
| 3 | `01` | 地址 | - |
| 4-8 | `00` | S6...S2 | 控制位高位填充 0 |
| 9 | `S1` | **控制位** | **对应 1-8 路状态** |
| 10-14 | `00` | E6...E2 | 使能位高位填充 0 |
| 15 | `E1` | **使能位** | **对应 1-8 路掩码** |
| 16 | `00` | 时间高 | 无效，填 0 |
| 17 | `00` | 时间低 | 无效，填 0 |
| 18 | `DD` | 结束位1 | - |
| 19 | `CC` | 结束位2 | - |

>
>

### 4.2 示例 (Hex)

* **打开第 1 路** (Mask=0x01, Set=0x01)
*
`CC DD A3 01 00 00 00 00 00 01 00 00 00 00 00 01 00 00 DD CC`


* **关闭第 1 路** (Mask=0x01, Set=0x00)
*
`CC DD A3 01 00 00 00 00 00 00 00 00 00 00 00 01 00 00 DD CC`


---

## 5. 读取指令 (查询状态)

### 5.1 读取继电器状态 (B3)

查询当前哪些继电器是吸合的。

*
**发送**: `CC DD B3 01 00 00 0D BE 7C` (固定指令)


* **返回**: `AA BB B3 01 [S6...S1] 0D`
* 对于 2-8 路，仅关注 `S1` 字节 (倒数第 2 个字节之前)。


### 5.2 读取输入与输出综合状态 (B2) - **推荐**

一条指令同时获取继电器状态和开关量输入状态。

*
**发送**: `CC DD B2 01 00 00 0D C0 80` (固定指令)

*
**返回**: `AA BB B2 01 [S6...S1] [K6...K1] BB AA`


* `S1`: 1-8 路继电器状态 (1=ON, 0=OFF)
* `K1`: 1-8 路输入端口状态 (1=触发, 0=未触发)

---

## 6. 代码实现参考 (TypeScript)

```typescript
/**
 * 生成 2-8 路板卡控制指令 (A1 协议)
 * @param address 设备地址 (默认 1)
 * @param relayMap 目标状态 Map (Key: 路数 1-8, Value: boolean)
 */
function generateControlA1(address: number, relayMap: Map<number, boolean>): string {
    let s_low = 0; // 控制位
    let e_low = 0; // 使能位

    relayMap.forEach((turnOn, channel) => {
        if (channel >= 1 && channel <= 8) {
            const bit = 1 << (channel - 1);
            e_low |= bit;           // 标记该路为"需要修改"
            if (turnOn) s_low |= bit; // 标记该路"目标为开启"
        }
    });

    const FUNC = 0xA1;
    const SH = 0x00, SL = s_low;
    const EH = 0x00, EL = e_low;

    // 校验算法: CH = Func + Addr + S + E
    const ch = (FUNC + address + SH + SL + EH + EL) & 0xFF;
    // CL = CH + CH
    const cl = (ch + ch) & 0xFF;

    const frame = [0xCC, 0xDD, FUNC, address, SH, SL, EH, EL, ch, cl];

    return frame.map(b => b.toString(16).padStart(2, '0').toUpperCase()).join('');
}

// 用法示例: 打开第 2 路
// const cmd = generateControlA1(1, new Map([[2, true]]));
// 输出: CCDDA10100020002A64C

```
